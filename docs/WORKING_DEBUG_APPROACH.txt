═══════════════════════════════════════════════════════════════════════════
WORKING APPROACH: Finding Operand 29 Processing Code
═══════════════════════════════════════════════════════════════════════════

PROBLEM: The address 6C2A7 from disassembly is an IDA Pro overlay address, not a
real DOS memory address. Overlays are loaded dynamically, so we can't breakpoint
them directly using the IDA addresses.

SOLUTION: Use memory breakpoint approach instead
═══════════════════════════════════════════════════════════════════════════

STEP 1: Start DOSBox-X and load the game
═══════════════════════════════════════════════════════════════════════════

  dosbox-x -debug

  In DOSBox:
    MOUNT C /home/user/5th_fleet_ed/game
    C:
    FLEET

═══════════════════════════════════════════════════════════════════════════
STEP 2: Load Scenario 2, then break and dump memory
═══════════════════════════════════════════════════════════════════════════

  1. In game menu: Select "New Game"
  2. Choose "Scenario 2: Russian Raiders"
  3. Get to the scenario briefing/setup screen
  4. Press ALT+PAUSE to break into debugger
  5. Dump all memory:
     MEMDUMPBIN scenario2_memory.bin

═══════════════════════════════════════════════════════════════════════════
STEP 3: Find the scenario data in memory dump
═══════════════════════════════════════════════════════════════════════════

  On the Linux side, search for the opcode pattern:

    hexdump -C scenario2_memory.bin | grep "0d 01 fe 0c 1d 0a"

  This searches for:
    0D 01    = TURNS(13)
    FE 0C    = TASK_FORCE(254)
    1D 0A    = ZONE_CHECK(29) <- our target operand

  Note the file offset where you find it.

  Example: if found at offset 0x3A1C4, the operand 29 (byte 0x1D) is at:
    0x3A1C4 + 4 = 0x3A1C8

═══════════════════════════════════════════════════════════════════════════
STEP 4: Convert file offset to segment:offset
═══════════════════════════════════════════════════════════════════════════

  DOSBox memory dumps are linear, starting at 0x00000.

  To convert to segment:offset for breakpoint:
    - If offset < 0x10000 (65536), it's in first 64KB
      Example: 0x3A1C8 = segment 0x3A1C, offset 0x8
      Or: segment 0x3000, offset 0xA1C8

  Generally: address = (segment * 16) + offset

  You can try different segment:offset combinations that give the same linear
  address. Common segments to try: DS, ES, or explicit values.

═══════════════════════════════════════════════════════════════════════════
STEP 5: Set memory READ breakpoint on operand byte
═══════════════════════════════════════════════════════════════════════════

  Back in DOSBox debugger:
    BPMR <segment>:<offset> 1

  Example:
    BPMR 3A1C:8 1

  Or try:
    BPMR 3000:A1C8 1

  Then continue:
    F5

═══════════════════════════════════════════════════════════════════════════
STEP 6: When breakpoint hits
═══════════════════════════════════════════════════════════════════════════

  The breakpoint should trigger when the game code READS the operand byte.

  When it breaks:
    R              ; Show registers - you'll see CS:IP where code is executing
    U CS:IP L 30   ; Disassemble 30 bytes from current position
    D DS:SI        ; Dump memory being accessed (if SI is used)
    D ES:DI        ; Or DI if that's the pointer

  Step through:
    F10            ; Step over
    F11            ; Step into calls

  Watch for:
    - What the code does with value 0x1D (29)
    - If it uses it as an index into a table
    - If it performs bit operations (AND, OR, XOR)
    - If values 7, 11, 17 appear

═══════════════════════════════════════════════════════════════════════════
ALTERNATIVE: Break on DOS file read
═══════════════════════════════════════════════════════════════════════════

  If memory breakpoint doesn't work, try catching the file read:

  Before loading scenario:
    BPINT 21 3F    ; Break on INT 21h, function 3Fh (read file)

  This will break on EVERY file read, so you'll need to:
    - Check if it's reading SCENARIO.DAT (check filename in registers/memory)
    - Note where the data is being read into (buffer address)
    - Set memory breakpoint on that buffer

═══════════════════════════════════════════════════════════════════════════
WHAT TO SEND ME:
═══════════════════════════════════════════════════════════════════════════

1. Output from: hexdump -C scenario2_memory.bin | grep "0d 01 fe 0c 1d 0a"
   (This shows where in memory the scenario data is)

2. The breakpoint command you used (e.g., BPMR 3A1C:8 1)

3. When breakpoint hits:
   - Output from R command (registers)
   - Output from U CS:IP L 30 (disassembly)
   - What you see as you step through with F10

4. Any observations about what the code does with value 29

═══════════════════════════════════════════════════════════════════════════
