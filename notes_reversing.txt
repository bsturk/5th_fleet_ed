- Startup and runtime scaffolding line up with Borland/Turbo Pascal: the program boots by querying DOS (MOV AH,0x30) and capturing its PSP values
  before installing custom handlers for CPU exceptions via INT 21h functions 35h/25h—Turbo Pascal’s standard safety net for divide/overflow traps
  (INT 0, 4, 5, 6) (disasm.txt:22, disasm.txt:120, disasm.txt:229). Most procedures return with RET n (e.g., RET 0x4), showing the Pascal/stdcall
  calling convention rather than C’s cdecl (disasm.txt:404). The bundled floating‑point error table ("Divide by 0", "Floating point error: %s") is
  the exact text shipped in Borland’s System unit (disasm.txt:250351).
- Graphics rely on the Borland Graphics Interface: the data segment is packed with BGI status strings plus .BGI/.CHR filenames, and the code contains
  the complete EGAVGA driver image (disasm.txt:251620, disasm.txt:251652, disasm.txt:36259). That combination points to Turbo Pascal’s Graph unit
  with the driver linked in statically (likely through RegisterBGIDriver or the $L EGAVGA.BGI directive).
- The embedded EGAVGA driver identifies itself as “BGI Device Driver (EGAVGA) 2.00 – Mar 21 1988,” placing the toolchain in the 1988–1990 Turbo/
  Borland Pascal 4.x/5.x era when that specific driver revision shipped (disasm.txt:36259).
- There’s no evidence of an external EXE packer: execution drops straight into the Pascal runtime’s heap/stack setup and DOS housekeeping with no
  decompression stub or tell‑tale signatures such as LZEXE/PKLITE banners (disasm.txt:22, disasm.txt:120). The inclusion of the uncompressed BGI
  payload further suggests the executable was distributed as-is.